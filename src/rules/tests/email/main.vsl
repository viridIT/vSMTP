#{
    connect: [
        rule "fail_mail_from_rewrite" || {
            try {
                vsl::rewrite_mail_from(server, "impossible@torewrite.com");
                return vsl::deny();
            } catch (err) {
                if "the email has not been received yet" in err { return vsl::next(); } else { return vsl::deny(); }
            }
        },

        rule "fail_mail_from_rewrite_address_format" || {
            try {
                vsl::rewrite_mail_from(server, "invalid");
                return vsl::deny();
            } catch (err) {
                if "could not rewrite mail_from with 'invalid' because it is not valid address" in err { return vsl::next(); } else { return vsl::deny(); }
            }
        },

        rule "fail_rcpt_rewrite_first_address_format" || {
            try {
                vsl::rewrite_rcpt(server, "invalid", "valid@email.com");
                return vsl::deny();
            } catch (err) {
                if "could not rewrite address 'invalid' because it is not valid address" in err { return vsl::next(); } else { return vsl::deny(); }
            }
        },

        rule "fail_rcpt_rewrite_second_address_format" || {
            try {
                vsl::rewrite_rcpt(server, "valid@email.com", "invalid");
                return vsl::deny();
            } catch (err) {
                if "could not rewrite address 'valid@email.com' with 'invalid' because it is not valid address" in err { return vsl::next(); } else { return vsl::deny(); }
            }
        },

        rule "invalid_timestamp_metadata" || {
            try {
                print(server.timestamp);
                return vsl::deny();
            } catch (err) {
                if "metadata are not available in this stage" in err { return vsl::next(); } else { return vsl::deny(); }
            }
        },

        rule "invalid_message_id_metadata" || {
            try {
                print(server.message_id);
                return vsl::deny();
            } catch (err) {
                if "metadata are not available in this stage" in err { return vsl::next(); } else { return vsl::deny(); }
            }
        },

        rule "invalid_retry_metadata" || {
            try {
                print(server.retry);
                return vsl::deny();
            } catch (err) {
                if "metadata are not available in this stage" in err { return vsl::next(); } else { return vsl::deny(); }
            }
        },

        rule "trailing" || vsl::accept(),
    ],

    preq: [
        rule "email_not_parsed" || {
            try {
                vsl::rewrite_mail_from(server, "impossible@torewrite.com");
                return vsl::deny();
            } catch (err) {
                if "the email has not been parsed yet" in err { return vsl::next(); } else { return vsl::deny() }
            }
        },

        rule "add_rcpt_email_not_parsed" || {
            try {
                vsl::add_rcpt(server, "impossible@toadd.com");
                return vsl::deny();
            } catch (err) {
                if "the email has not been parsed yet" in err { return vsl::next(); } else { return vsl::deny() }
            }
        },

        rule "remove_rcpt_email_not_parsed" || {
            try {
                vsl::remove_rcpt(server, "impossible@toremove.com");
                return vsl::deny();
            } catch (err) {
                if "the email has not been parsed yet" in err { return vsl::next(); } else { return vsl::deny() }
            }
        },

        rule "rewrite_rcpt_email_not_parsed" || {
            try {
                vsl::rewrite_rcpt(server, "impossible@torewrite.com", "impossible@torewrite.com");
                return vsl::deny();
            } catch (err) {
                if "the email has not been parsed yet" in err { return vsl::next(); } else { return vsl::deny() }
            }
        },

        rule "trailing" || vsl::accept(),
    ],

    postq: [
        action "print_client_data" || {
            vsl::log("debug", "email received.");
            vsl::log("debug", `connexion timestamp: ${server.connexion_timestamp}`);
            vsl::log("debug", `ip: ${server.client_addr}`);
            vsl::log("debug", `helo: ${server.helo}`);
            vsl::log("debug", `mail_from: ${server.mail_from}`);
            vsl::log("debug", `metadata {\n  mail timestamp: ${server.timestamp}\n  message id: ${server.message_id}\n  retries: ${server.retry}\n}`);

            vsl::log("trace", server.to_string());
            vsl::log("trace", server.to_debug());

            print(server.timestamp.to_string());
            print(server.timestamp.to_debug());
        },

        action "rewrite" || {
            vsl::add_rcpt(server, "added@rcpt.com");
            vsl::remove_rcpt(server, "rcpt@toremove.org");
            vsl::rewrite_rcpt(server, "rcpt@torewrite.net", "new@rcpt.net");
            vsl::rewrite_mail_from(server, "new@mailfrom.eu");
        },

        rule "check_rewrites" || {
            if "added@rcpt.com" in server.rcpt
            && !("rcpt@toremove.org" in server.rcpt)
            && "new@rcpt.net" in server.rcpt
            && !("rcpt@torewrite.net" in server.rcpt)
            && server.mail_from is "new@mailfrom.eu" {
                vsl::next()
            } else {
                vsl::deny()
            }
        },

        rule "trailing" || vsl::accept(),
    ]
}