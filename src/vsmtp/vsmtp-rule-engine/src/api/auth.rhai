/*
 * vSMTP mail transfer agent
 * Copyright (C) 2022 viridIT SAS
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see https://www.gnu.org/licenses/.
 *
*/

//
// standard library for authentication
//

/// Block relaying. Inspect all recipients domains & check if those are registered in the
/// root domain or virtual ones.
///
/// The check is skipped if the client is authenticated or if it's api is present in the
/// `allowed_host` parameter.
///
/// NOTE: you can use this function starting from the `rcpt` stage.
///
/// # Returns
///   * `next` if all recipients are valid.
///   * `deny(554)` if any recipient tries to use the server as a relay.
///
/// ### Example
/// ```
/// rcpt: [
///     rule "check relay" || vsl::check_relay(net_192)
/// ]
/// ```
///
fn check_relay(allowed_hosts) {
    for rcpt in ctx().rcpt_list {
        if !(ctx().is_authenticated || (ctx().client_ip in allowed_hosts))
            && !in_domain(rcpt) {
                remove_rcpt(rcpt.to_string());
                return deny(code554_7_1);
        }
    }

    next()
}

/// check spf record.
/// a wrapper with the policy set to "strict" by default.
///
/// # Args
/// @identity: "helo" | "mail_from" | "both"
/// @header: "spf" | "auth" | "both" | "none"
///
fn check_spf(identity, header) {
    check_spf(identity, header, "strict")
}

/// create key-value pairs of spf results
/// to inject into the spf or auth headers.
private fn spf_key_value_list(query) {
`receiver=${hostname()}; client-ip=${ctx().client_ip};
 identity=mailfrom; envelope_from=${ctx().mail_from};
 ${
   if "mechanism" in query { `mechanism=${query.mechanism};` }
   else if "problem" in query { `problem=${query.problem};` }
 }`
}

/// Record results in a spf header (RFC 7208-9)
private fn spf_header(query) {
    `${query.result} ${spf_key_value_list(query)}`
}

/// Record results in the auth header (RFC 7208-9)
fn auth_header(query) {
`${hostname()}; spf=${query.result}
 reason="${spf_key_value_list(query)}"
 smtp.mailfrom=${ctx().mail_from}`;
}

/// check spf record.
/// Sender Policy Framework (RFC 7208).
///
/// # Args
/// @identity: "helo" | "mail_from" | "both"
/// @header: "spf" | "auth" | "both" | "none"
/// @policy: "strict" | "soft"
///
/// # Return
/// - deny() or next()
///
/// # Required stage : rcpt+
///
/// # Example
/// ```
/// rcpt: [
///     rule "check spf" || check_spf("both", "spf", "soft")
/// ]
/// ```
fn check_spf(identity, header, policy) {

    const AUTH_HEADER = "Authentication-Results";
    const SPF_HEADER = "Received-SPF";

<<<<<<< HEAD
    if policy == "strict" {
        switch query.result {
            "pass" => {},
            "fail" => return deny(code550_7_23),
            "temperror" => return deny(code451_7_24),
            "permerror" => return deny(code550_7_24),
            _ => set_header("subject", "JUNK: " + get_header("subject")),
        }
    }

    // Record the result in a header (RFC 7208-9)
    let spf_header =
        // + if query.result == "fail" { ` ( ${query.cause} )` }
`${query.result}
 receiver=${hostname()}; client-ip=${ctx().client_ip};
 identity=mailfrom; envelope_from=${ctx().mail_from};
 ${if query.result == "pass" { `mechanism=${query.cause};` }}`;
        // + if (query.result == "temperror" || query.result == "permerror") { "\n problem=${query.cause};" };

    let auth_header =
`${hostname()}; spf=${query.result}
 reason=\"${spf_header}\" smtp.mailfrom=${ctx().mail_from}`;
=======
    let query = sys::check_spf(ctx(), srv(), identity);
>>>>>>> 8854b3cf0444d51251bbb96199586b2483f2ce86

    // TODO: The Received-SPF header field is a trace field
    // and SHOULD be prepended to the existing header, above the Received: field
    // It MUST appear above all other Received-SPF fields in the message.
    switch header {
        // It is RECOMMENDED that SMTP receivers record the result"
        "spf" => prepend_header(SPF_HEADER, spf_header(query)),
        "auth" => prepend_header(AUTH_HEADER, auth_header(query)),
        "both" => {
            prepend_header(AUTH_HEADER, auth_header(query));
            prepend_header(SPF_HEADER, spf_header(query));
        },
        _ => {},
    }

    if policy == "strict" {
        switch query.result {
            "pass" => next(),
            "fail" => deny(code550_7_23),
            "softfail" => deny(code550_7_23),
            "temperror" => deny(code451_7_24),
            "permerror" => deny(code550_7_24),
            _ => next(),
        }
    } else if policy == "soft" {
        switch query.result {
            "fail" => deny(code550_7_23),
            "temperror" => deny(code451_7_24),
            "permerror" => deny(code550_7_24),
            _ => next(),
        }
    } else {
        throw `spf 'policy' argument must be 'strict' or 'soft', not '${policy}'`;
    }
}

///
/// Null MX sender policy (RFC 7505).
///
/// - args : no
/// - return : deny() or next()
///
/// ### Required stage : mail+
///
/// ### Example
/// ```
/// rcpt: [
///     rule "check null MX" || vsl::check_null_mx_sender!()
/// ]
/// ```
fn check_null_mx_sender() {

    let srv_domain = get_domain();

    // Check if policy is already applied or set to none
    if (srv_domain.auth.null_mx.trigger != "vsl") || (srv_domain.auth.null_mx.policy == "none") {
        return sys::next();
    }

    let query = sys::check_null_mx_sender(ctx().mail_from.domain);
    // sys::check_null_MX_sender(ctx().mail_from.domain)
    //
    // - returns : boolean (true if null MX found)

    // Null MX record not found, skip the rule.
    if !query {
        return sys::next();
    }

    // Null MX record found.
    if srv_domain.auth.null_mx.policy == "strict" {
        return sys::deny(code550_7_27);
    }

    // There's no standard header for null MX
    if srv_domain.auth.null_mx.header == "X-nullMX" {
        let header = `${hostname()}; null MX sender detected for ${ctx().mail_from.domain}`;
        sys::prepend_header(ctx(), "X-NullMX", header);
    }

    // Modify the subject
    sys::set_header(ctx(), "Subject", "JUNK:" + sys::get_header(ctx(), "Subject"));

    return sys::next();
}

fn dkim_verify() {
    let policy = #{
        // avoid infinite loop and dos/ddos attack
        nbr_headers: 3,
        // among ["first_one", "cycle"]
        on_multiple_key_records: "cycle",
    };

    let dkim_signatures = msg().headers
        .named("DKIM-Signature")
        .take(policy.nbr_headers)
        .values;

    for i in dkim_signatures {
        try {
            // `signature` is a valid DkimSignature, with rfc6376 valid format
            let signature = parse_signature(i);

            // TODO: verify expiration

            // NOTE: for any reason, you can decide to ignore the signature
            // if signature... {
            //     continue;
            // }

            // the dns query may result in multiple public key,
            // the registry with invalid format are ignored
            for key in get_public_key(srv(), signature, policy.on_multiple_key_records) {
                try {
                    print(key);

                    sys::dkim_verify(msg(), signature, key);

                    // if key.has_test_flag {
                    // TODO: log, and consider as unsigned
                    // }

                } catch (e) {
                    print(e);
                }
            }

        } catch (e) {
            print(e);
            // TODO: if header ParseError, ignored

            // TEMPFAIL ?
        }
    }
}
